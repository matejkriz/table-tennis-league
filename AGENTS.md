# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

A local-first Progressive Web App (PWA) for tracking table tennis league ratings using the STR (Skill-based Team Ranking) system. Built with React, TanStack Router, and Evolu for local-first data synchronization. Supports English and Czech languages with automatic browser language detection.

## Common Commands

### Development

```bash
yarn dev              # Start development server (Vite)
yarn build            # Type-check with tsc and build for production
yarn preview          # Preview production build locally
```

### Linting and Quality

```bash
yarn lint             # Run ESLint on the codebase
yarn typecheck        # Run TypeScript type checking (REQUIRED after code changes)
```

### Testing

```bash
yarn test             # Run tests in watch mode
yarn test:ui          # Run tests with Vitest UI
yarn test:coverage    # Run tests with coverage report
```

### Utilities

```bash
yarn clean                    # Remove node_modules, dist, and build artifacts
yarn generate-pwa-assets      # Generate PWA icons and assets
```

## Architecture

### Data Layer - Evolu

The application uses **Evolu** (a local-first database framework) for data persistence and synchronization:

- **Schema definition**: `src/evolu/client.ts` defines the database schema with three tables:
  - `player`: Player information with name and initial rating
  - `match`: Match records linking two players with a winner and timestamp
  - `_uiPreference`: Local-only UI state (underscore prefix means not synced across devices)

- **Authentication**: Uses `localAuth` from `@evolu/react-web` to manage owner profiles. The database name includes the owner ID for multi-profile support.

- **Queries**: Pre-defined queries (`playersQuery`, `matchesQuery`, `uiPreferencesQuery`) are created using `evolu.createQuery()` and consumed via the `useQuery()` hook.

- **Data operations**: Use `insert()` and `update()` methods from `useEvolu()` hook. All writes go through Evolu's validation system with typed schemas.

- **Type safety**: Evolu provides strong typing with branded types (`PlayerId`, `MatchId`, etc.) and validation schemas (`NonEmptyTrimmedString100`, `NonNegativeNumber`, etc.).

### Rating System

The STR rating system is implemented in `src/hooks/useLeagueData.ts`:

- **K-factor**: Set to `16` (constant `K_FACTOR`)
- **Rating calculation**: Uses standard Elo formula with expected score calculation
- **Match processing**: All matches are sorted by `playedAt` timestamp and processed sequentially to compute rating deltas
- **Output**: Returns `LeagueData` object containing players, matches with rating details, and current ranking

The `useLeagueData` hook is the single source of truth for all rating computations and should be used whenever rating data is needed.

### Routing

Uses **TanStack Router** with file-based routing:

- Route files are in `src/routes/`
- `routeTree.gen.ts` is auto-generated by `@tanstack/router-plugin/vite`
- Root route (`__root.tsx`) wraps the app in `EvoluProvider` and `Suspense`
- Current routes:
  - `/` (index.tsx): Main dashboard with player management, match recording, ranking, and history
  - `/match` (match.tsx): Standalone match recording page
  - `/stats` (stats.tsx): Standalone statistics and leaderboard page

### UI Components

Component patterns used throughout:

- **CollapsibleSection**: Reusable collapsible container that persists open/closed state in Evolu's `_uiPreference` table using the `useCollapsibleState` hook
- **RatingChart**: Interactive rating history visualization using `recharts` library
  - Displays player rating trends over the last 90 days
  - Shows projected rating changes for upcoming match outcomes
  - Uses event-based data points (only creates points at match dates) for performance
  - Color-coded: Player A (orange `#F7931A`), Player B (blue `#3B82F6`)
  - Dashed lines indicate projections, solid lines show historical ratings
  - Located in `src/components/RatingChart.tsx`
- **MatchRecorder**: Match recording form with winner selection and rating preview
  - Integrates RatingChart in a collapsible section
  - Color-coordinated UI (Player A = orange, Player B = blue)
  - Shows "Winner" badge with trophy icon, "Loser" badge with sad face icon
  - Displays projected rating changes before match submission
- **Form handling**: Forms use Evolu's type validation with `formatTypeError()` to display user-friendly error messages
- **Styling**: Tailwind CSS utility classes with custom theme color `#F7931A` (orange) as the primary accent
- **Icons**: `@tabler/icons-react` for all icons
- **Charts**: `recharts` for data visualization (LineChart, responsive containers, tooltips)

### State Management

- **Server state**: Managed entirely through Evolu queries (`useQuery()`)
- **UI state (persisted)**: Stored in Evolu's `_uiPreference` table for collapsible sections
- **Local form state**: React's `useState()` for form inputs and temporary UI state

### Internationalization (i18n)

The app supports **English** and **Czech** languages using `react-i18next` with natural English keys:

**Architecture**:

- `src/i18n/index.ts`: i18next configuration with browser language detection
- `src/i18n/locales/cs.json`: Czech translations (English → Czech mapping)
- `src/hooks/useLanguagePreference.ts`: Custom hook syncing i18next with Evolu storage
- `src/components/LanguageSelector.tsx`: UI component for language switching in Settings

**Natural English Keys Approach**:

The app uses English text directly as translation keys - no separate English translation file needed:

```tsx
// In component:
const { t } = useTranslation();
return <button>{t("Add player")}</button>;

// When language is English: displays "Add player" (the key itself)
// When language is Czech: displays "Přidat hráče" (from cs.json)
```

**i18next Configuration**:

```typescript
i18next.init({
  fallbackLng: "en",
  supportedLngs: ["en", "cs"],
  keySeparator: false, // Allows keys with dots like "e.g. Katarína"
  nsSeparator: false, // Allows keys with colons
  resources: {
    cs: { translation: csTranslations },
    // No 'en' resource - falls back to key
  },
});
```

**How to Use Translations in Components**:

1. Import `useTranslation` hook:

   ```tsx
   import { useTranslation } from "react-i18next";
   ```

2. Get `t` function in component:

   ```tsx
   const { t } = useTranslation();
   ```

3. Wrap English text strings:

   ```tsx
   // Simple text
   <h1>{t("Table Tennis League")}</h1>

   // With interpolation
   <p>{t("This device has {{count}} registered profiles.", { count: 5 })}</p>

   // In attributes
   <input placeholder={t("Player name")} />
   <button title={t("Delete match")} />
   ```

4. For date formatting, also access `i18n`:
   ```tsx
   const { t, i18n } = useTranslation();
   date.toLocaleDateString(i18n.language, { month: "short", day: "numeric" });
   ```

**Adding New Translations**:

1. Use English text in code wrapped in `t()`:

   ```tsx
   <span>{t("New feature text")}</span>
   ```

2. Add Czech translation to `src/i18n/locales/cs.json`:

   ```json
   {
     "New feature text": "Nový text funkce"
   }
   ```

3. **Important**: If you change existing English text in code, update the corresponding key in `cs.json`

**Language Persistence**:

- User language choice stored in Evolu's `_uiPreference` table with key `"app-language"`
- On first visit: Browser language detected (Czech if system is Czech, otherwise English)
- After manual selection: User's choice persists locally per device
- Not synced across devices (local preference only)

**Language Switching**:

Users can switch language in Settings page:

- Language selector shows "English" and "Czech" (localized)
- Selected language has orange background with checkmark
- Changes apply immediately to all components

**Testing with i18n**:

Tests are configured to return English text (keys as-is):

```typescript
// In src/test/setup.ts
vi.mock("react-i18next", () => ({
  useTranslation: () => ({
    t: (key: string) => key, // Returns the key itself (English)
    i18n: { language: "en", changeLanguage: vi.fn() },
  }),
}));
```

This means test assertions use English strings:

```tsx
expect(screen.getByText("Add player")).toBeInTheDocument();
```

**Date and Number Formatting**:

Always use `i18n.language` for locale-aware formatting:

```tsx
const { i18n } = useTranslation();

// Dates
date.toLocaleDateString(i18n.language, options);
date.toLocaleString(i18n.language, options);

// Numbers
number.toLocaleString(i18n.language);
```

Include `i18n.language` in dependency arrays to re-render on language change:

```tsx
useMemo(() => {
  // ... calculations using i18n.language for formatting
}, [otherDeps, i18n.language]);
```

## Key Technical Details

### Evolu Data Flow

1. All database mutations use typed schemas with built-in validation
2. Queries are reactive - components re-render when underlying data changes
3. The `_uiPreference` table (underscore prefix) stores local-only data that doesn't sync
4. Use `onComplete` callback in insert/update operations for post-mutation actions (e.g., resetting forms)

### Type Safety and Branded Types

TypeScript strict mode is enabled with Evolu's branded type system for enhanced type safety.

**Evolu Branded Types**:

Evolu uses TypeScript's branded types pattern via the `Brand<B>` interface to distinguish otherwise identical base types. This prevents accidental type confusion at compile time.

- **ID types**: Created with factory functions (e.g., `Evolu.id("Player")` creates `PlayerId` type)
  ```typescript
  export const PlayerId = Evolu.id("Player");
  export type PlayerId = typeof PlayerId.Type;
  ```
- **Validation schemas**: Built-in branded validators ensure data integrity
  - `Evolu.NonEmptyTrimmedString100`: String with min 1, max 100 chars, trimmed
  - `Evolu.NonNegativeNumber`: Number >= 0
  - `Evolu.DateIso`: ISO 8601 date string
  - `Evolu.SqliteBoolean`: SQLite boolean (0 or 1)

**Type Patterns**:

- **Query result types**: Inferred from queries, not schemas (e.g., `PlayerRow`, `MatchRow`)
  ```typescript
  export const playersQuery = evolu.createQuery((db) => ...);
  export type PlayerRow = typeof playersQuery.Row;
  ```
- **Type narrowing**: Use `$narrowType<>()` in queries to refine types when filtering nullable fields
- **Production code**: Pass plain values to `insert()`/`update()` - Evolu validates at runtime
- **Boundary assertions**: Only use `as` type assertions at DOM boundaries (e.g., `event.target.value as PlayerId`)

**Testing with Branded Types**:

Test code requires special handling for branded types since we bypass Evolu's validation:

- **Test helpers**: Centralized mock data creators in `src/test/helpers.ts`
  - `createMockPlayer()`: Accepts plain types, returns `PlayerRow`
  - `createMockMatch()`: Accepts plain types, returns `MatchRow`
- **Single assertion per object**: Helpers use one `as PlayerRow` cast instead of per-field assertions
- **Why it's acceptable**: Test data doesn't go through validation; helpers are themselves validated by tests
- **Pattern matches Evolu docs**: Direct casting "is unsafe, so [factory functions] must be unit-tested"

### PWA Configuration

- Service worker registration type: `autoUpdate`
- Workbox handles caching of all assets including `.wasm` files (required for SQLite WebAssembly)
- Manifest defined in `vite.config.ts`
- Assets generated from `pwa-assets.config.ts`

### Vite Configuration

Notable optimizeDeps exclusions:

- `@evolu/sqlite-wasm`: SQLite WebAssembly module
- `kysely`: SQL query builder (peer dependency of Evolu)
- `@evolu/react-web`: Evolu React bindings

These are excluded to avoid Vite's dependency pre-bundling which can cause issues with WebAssembly modules.

**Chart Library**:

- `recharts` (v3.7.0+): Used for rating history visualization
  - Provides LineChart, XAxis, YAxis, Tooltip, Legend, and ResponsiveContainer components
  - Automatically optimized by Vite for production builds
  - Mock in tests using `vi.mock("recharts")` to avoid rendering issues in jsdom

### Testing Setup

The project uses **Vitest** with **React Testing Library** for testing:

- **Test framework**: Vitest (compatible with Vite configuration)
- **Component testing**: React Testing Library
- **IndexedDB mock**: `fake-indexeddb` polyfills IndexedDB for Evolu in tests
- **Test files**: Located alongside source files with `.test.ts` or `.test.tsx` extension

**Key testing considerations:**

- **Evolu mocking**: Test files mock the Evolu client module before imports to prevent WebWorker initialization in jsdom
- **Mock pattern**: Each test file includes `vi.mock("../evolu/client")` at the top with mocked hooks (`useEvolu`, `useQuery`, etc.)
- **i18n mocking**: Global mock in `src/test/setup.ts` returns keys as-is (English behavior) - use English strings in test assertions
- **Test setup**: Global setup in `src/test/setup.ts` includes fake-indexeddb, @testing-library/jest-dom matchers, and i18next mock

**Coverage:**

- Rating calculation logic (`useLeagueData.ts`): 11 tests covering K-factor, Elo formula, ranking, and edge cases
- Critical components: `AddPlayerForm`, `MatchRecorder`, `CollapsibleSection`, `RatingChart`
- Chart projection logic: Tests verify correct delta application (especially for underdog wins with larger deltas)
- Total: 60+ tests across 5 test files

Run tests in watch mode during development for instant feedback on changes.

**Testing Charts:**

- Mock `recharts` components to avoid rendering complexity in tests
- Capture `data` prop from LineChart to verify chart data calculations
- Test projection calculations ensure deltas are applied correctly (not using `Math.abs()` which would break underdog scenarios)

### Type Checking

**CRITICAL**: TypeScript strict mode is enabled and type checking must pass before committing changes.

- Run `yarn typecheck` after every code change
- **No `any` types allowed** without explicit justification
- **Test mock data**: Use test helpers from `src/test/helpers.ts`:
  - `createMockPlayer({ id, name, initialRating })` for player fixtures
  - `createMockMatch({ id, playerAId, playerBId, winnerId, playedAt })` for match fixtures
  - Helpers accept plain JavaScript types and handle branded type assertions internally
  - This centralizes "as" assertions to single location per object instead of per field
- **Mock function typing**: Define explicit union types for mock returns (e.g., `type InsertResult = { ok: true } | { ok: false; error: { type: string } }`)
- Evolu query results (PlayerRow, MatchRow) do not include `isDeleted` - it's filtered by queries automatically

## Development Guidelines

### Working with Evolu

- Always use the pre-defined queries (`playersQuery`, `matchesQuery`, etc.) rather than writing raw SQL
- For mutations, pass plain JavaScript values to `insert()`/`update()` - Evolu validates at runtime using branded type schemas
- Handle validation errors using `formatTypeError()` for consistent error messages
- Remember that `_uiPreference` table is local-only (not synced)
- **Branded types**: See "Type Safety and Branded Types" section for details on Evolu's type system and testing patterns

### Adding New Features

- For new database tables, update the schema in `src/evolu/client.ts`
- Create typed queries using `evolu.createQuery()`
- Export branded ID types (e.g., `export const FooId = Evolu.id("Foo")`)
- Use TanStack Router's file-based routing for new pages
- Follow existing component patterns for consistency (especially CollapsibleSection for grouping content)
- **Localization**: Wrap all user-facing text in `t()` function and add Czech translations to `src/i18n/locales/cs.json`
- Write tests for new business logic and critical components (place `.test.ts` files alongside source files)
- **Always run `yarn typecheck` after code changes** - zero TypeScript errors required

### Styling Conventions

- Use Tailwind utility classes directly in components
- Primary accent color: `#F7931A` (orange)
- Background: `#fafafa` (very light gray)
- Text: `black` with opacity variants for hierarchy (`black/60`, `black/40`, etc.)
- Rounded corners: typically `rounded-xl` or `rounded-full` for buttons
- Consistent spacing: use the Tailwind scale (`p-4`, `p-5`, `p-6`, etc.)

### Plan Mode Default

- Enter plan mode for ANY non-trivial task (3+ steps or architectural decisions)
- If something goes sideways, STOP and re-plan immediately - don't keep pushing
- Use plan mode for verification steps, not just building
- Write detailed specs upfront to reduce ambiguity

### Subagent Strategy

- Use subagents liberally to keep main context window clean
- Offload research, exploration, and parallel analysis to subagents
- For complex problems, throw more compute at it via subagents
- One task per subagent for focused execution

### Self-Improvement Loop

- After ANY correction from the user: update "docs/LESSONS.md" with the pattern
- Write rules for yourself that prevent the same mistake
- Ruthlessly iterate on these lessons until mistake rate drops
- Review lessons at session start for relevant project

### Verification Before Done

- Never mark a task complete without proving it works
- Diff behavior between main and your changes when relevant
- Ask yourself: "Would a staff engineer approve this?"
- Run tests, check logs, demonstrate correctness

### Demand Elegance (Balanced)

- For non-trivial changes: pause and ask "is there a more elegant way?"
- If a fix feels hacky: "Knowing everything I know now, implement the elegant solution"
- Skip this for simple, obvious fixes - don't over-engineer
- Challenge your own work before presenting it

### Autonomous Bug Fixing

- When given a bug report: just fix it. Don't ask for hand-holding
- Point at logs, errors, failing tests - then resolve them
- Zero context switching required from the user
- Go fix failing CI tests without being told how

# Task Management

1. **PLan First**: Write plan to "tasks/todo.md" with checkable items
2. **Verify Plan**: Check in before starting implementation
3. **Track Progress**: Mark items complete as you go
4. **Explain Changes**: High-level summary at each step
5. **Document Results**: Add review section to "docs/tasks/{short-title-of-current-task.md}"
6. **Capture Lessons**: Update "docs/LESSONS.md" after corrections

## Core Principles

- **Simplicity First**: Make every change as simple as possible. Impact minimal code.
- **No Laziness**: Find root causes. No temporary fixes. Senior developer standards.
- **Minimal Impact**: Changes should only touch what's necessary. Avoid introducing bugs.
